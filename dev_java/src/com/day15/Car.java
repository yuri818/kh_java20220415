package com.day15;
//선언부에 abstract가 오면 추상클래스
//인터페이스는 생성자를 가질 수 없지만 추상클래스는 생성자를 가질 수 있다.
//일반메소드와 추상메소드 모두를 가질 수 있다.
//그러니까 추상메소드 앞에 abstract는 절대로 생략할 수 없다.
//: 왜냐하면 일반메소드와 구분해야 하니깐...
public abstract class Car implements MoveBehavior{
	public int speed = 0;
	public int wheelNum = 0;
	//추상메소드는 어떤 자동차가 될지를 정할 수가 없어서 추상메소드로 하기로 함
	//세미콜론으로 끝나는 메소드는 추상메소드이다.
	public abstract void display();
	//좌중괄호와 우중괄호가 있는 메소드를 일반메소드라 한다.
	@Override
	public void run() { //엑셀을 밟으면 그때마다 호출된다.
		speed += 1;
	}
}

/*
	인터페이스는 추상클래스보다 더 추상적이다.
	 :왜냐하면 추상메소드만 가지니까
	인터페이스와 추상클래스 공통점은 둘 다 단독으로 인스턴스화 불가함
	 :이거때문에 다형성이 가능한 것이다.
	 :이거때문에 구현체 클래스에 따라서 같은 이름의 메소드를 호출하더라도
	서로 다른 메소드가 실행되어 다른 기능이 제공되는 것임 - 다형성
	인터페이스는 오직 추상메소드만 가질 수 있다
	 :그러니까 abstract예약어는 생략이 가능함.
	인터페이스는 생성자를 가질 수 없다. 인터페이스는 변수도 가질 수 없다.
	추상클래스는 생성자를 갖는다.
	추상클래스는 일반메소드와 추상메소드를 모드를 가질 수 있다.
	추상클래스에서는 abstract 생략할 수 없다.
	추상클래스가 있어서 다형성이 가능해 진다.
	추상클래스와 인터페이스 때문에 선언부의 타입과 생성부의 타입이 다를 수 있다.
	단, 자바는 이럴 경우 생성부의 타입으로 객체가 생성된다. 메모리에 로딩된다.
	
	클래스 타입 변수명 = new 클래스 타입(); - 스탠다드
	추상클래스 변수명 = new 구현체 클래스(); - 잘하는 사람 - 다형성 가능해짐 - 코드수정이 줄어듦
	인터페이스 변수명 = new 구현체클래스();
	
*/